package codes.yousef.sigil.schema

import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

/**
 * Comprehensive E2E tests for SigilSceneBuilder and the DSL.
 * Tests builder methods, nested group building, and sigilScene DSL entry point.
 */
class SigilSceneBuilderTest {

    // ===== Empty Scene Tests =====

    @Test
    fun sigilScene_emptyBuilder_createsEmptyScene() {
        val scene = sigilScene { }
        
        assertTrue(scene.rootNodes.isEmpty())
        assertEquals(SceneSettings(), scene.settings)
    }

    // ===== ID Generation Tests =====

    @Test
    fun autoGeneratedIds_areUnique() {
        val scene = sigilScene {
            mesh()
            mesh()
            mesh()
            light()
            light()
            camera()
            group { }
        }
        
        val ids = scene.rootNodes.map { it.id }
        val uniqueIds = ids.toSet()
        
        assertEquals(ids.size, uniqueIds.size, "All auto-generated IDs should be unique")
    }

    @Test
    fun autoGeneratedIds_areNotEmpty() {
        val scene = sigilScene {
            mesh()
            light()
            camera()
            group { mesh() }
        }
        
        scene.flattenNodes().forEach { node ->
            assertTrue(node.id.isNotEmpty(), "Auto-generated ID should not be empty")
        }
    }

    // ===== Complex Scene Tests =====

    @Test
    fun complexScene_buildsCorrectly() {
        val scene = sigilScene {
            settings(
                backgroundColor = 0xFF87CEEB.toInt(),
                shadowsEnabled = true
            )
            
            // Ground
            mesh(
                id = "ground",
                geometryType = GeometryType.PLANE,
                geometryParams = GeometryParams(width = 100f, height = 100f),
                position = listOf(0f, 0f, 0f),
                rotation = listOf(-1.5708f, 0f, 0f)
            )
            
            // Objects group
            group(id = "objects", position = listOf(0f, 0f, 0f)) {
                mesh(id = "cube", geometryType = GeometryType.BOX, position = listOf(-2f, 0.5f, 0f))
                mesh(id = "sphere", geometryType = GeometryType.SPHERE, position = listOf(0f, 0.5f, 0f))
                mesh(id = "cylinder", geometryType = GeometryType.CYLINDER, position = listOf(2f, 0.5f, 0f))
            }
            
            // Lights
            light(id = "ambient", lightType = LightType.AMBIENT, intensity = 0.3f)
            light(id = "sun", lightType = LightType.DIRECTIONAL, position = listOf(10f, 20f, 10f))
            
            // Camera
            camera(id = "main-camera", position = listOf(0f, 5f, 10f), lookAt = listOf(0f, 0f, 0f))
        }
        
        assertEquals(5, scene.rootNodes.size) // ground, objects, ambient, sun, camera
        
        val objectsGroup = scene.rootNodes[1] as GroupData
        assertEquals(3, objectsGroup.children.size)
        
        val foundCube = scene.findNodeById("cube")
        assertNotNull(foundCube)
        assertEquals(GeometryType.BOX, (foundCube as MeshData).geometryType)
    }

    @Test
    fun builder_sceneIsImmutableAfterBuild() {
        val builder = SigilSceneBuilder()
        builder.mesh(id = "mesh-1")
        val scene1 = builder.build()
        
        // Adding more after build should not affect the already built scene
        builder.mesh(id = "mesh-2")
        val scene2 = builder.build()
        
        // Actually, the current implementation allows this - testing actual behavior
        // scene1 has 1 node, scene2 has 2 nodes (because builder is reused)
        assertEquals(1, scene1.rootNodes.size)
        assertEquals(2, scene2.rootNodes.size)
    }

    // ===== Round-Trip Tests =====

    @Test
    fun builtScene_serializesCorrectly() {
        val scene = sigilScene {
            mesh(id = "mesh-1", geometryType = GeometryType.TORUS)
            group(id = "group-1") {
                mesh(id = "nested-mesh")
                light(id = "nested-light")
            }
            settings(fogEnabled = true)
        }
        
        val json = scene.toJson()
        val restored = SigilScene.fromJson(json)
        
        assertEquals(scene, restored)
    }

    @Test
    fun deeplyNestedScene_serializesCorrectly() {
        val scene = sigilScene {
            group(id = "l1") {
                group(id = "l2") {
                    group(id = "l3") {
                        group(id = "l4") {
                            group(id = "l5") {
                                mesh(id = "deep-mesh")
                            }
                        }
                    }
                }
            }
        }
        
        val json = scene.toJson()
        val restored = SigilScene.fromJson(json)
        
        val found = restored.findNodeById("deep-mesh")
        assertNotNull(found)
    }
}
